<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //concat, filter, map, slice, 스프레드(전개) 연산자 

        console.log("1. ================================= 스프레드 연산자");        
        const a = [1,2,3];
        const b = [...a];
        // const b = a;
        b.push(4);
        console.log(`a의 값은:${a}`); // 1,2,3
        console.log(`b의 값은:${b}`); // 1,2,3,4
        // 응용
        const c2 = [0,...a,4]; //concat과 동일.
        console.log(`c2의 값은:${c2}`); // 1,2,3,4

        console.log("2. ================================= 추가하기");
        const a2 = [1,2,3];
        const b2 = a2.concat(4);
        console.log(`a의 값은:${a2}`); // 1,2,3
        console.log(`b의 값은:${b2}`); // 1,2,3,4


        console.log("3. ================================= 걸러내기"); //삭제하기
        const a3 = [1,2,3];
        const b3 = a3.filter( (n)=>{ return n != 1;} ); // boolean 을 return 받는다. -> true만 걸러낸다.
        console.log(b3);  //삭제 할때 주로 사용 // 2,3


        console.log("4. ================================= 잘라내기");
        const a4 = [1,2,3];
        const b4 = a4.slice(0,2);
        console.log("c4의 값은: ",b4); // [1,2]
        // const c4 = [a4.slice(0,2)];
        const c4 = [...a4.slice(0,2),4,...a4.slice(2,3)];
        console.log("c4의 값은: ",c4); [[1,2]]


        console.log("5. ================================= 반복하기");
        const a5 = [1,2,3];
        /*
        for(let i=0; i<a5.length; i++){
            console.log(a5[i]);
        }
        */
    //    a5.forEach( (n)=>{console.log(n)} ); //리턴 못함.
        const b5 = a5.map( (n)=> {return n+10;} ); // const b5 = [...a5]; 같음.
        console.log(b5);
    </script>
</body>
</html>